package main

// https://github.com/istio/client-go/blob/master/cmd/example/client.go
// https://pizi.netlify.app/posts/kubernetes-client-go-example/#pod%E3%81%AE%E5%8F%96%E5%BE%97
// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run client.go

// Golang restfulapi
// https://go.dev/doc/tutorial/web-service-gin
import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"os"
	"strings"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"

	_ "k8sclienttest/docs" // directory name

	networkingv1alpha3 "istio.io/api/networking/v1alpha3"
	"istio.io/client-go/pkg/apis/networking/v1alpha3"
	"istio.io/client-go/pkg/clientset/versioned"
	versionedclient "istio.io/client-go/pkg/clientset/versioned"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/dynamic"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	//"k8s.io/apimachinery/pkg/runtime"
	//sigv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

//	_ "use_swagger/docs" _ "k8sclienttest/docs"
// _ "github.com/swaggo/gin-swagger/example/basic/docs" // docs is generated by Swag CLI, you have to import it.

// @Summary registerGateway
// @Description registerGateway
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   ip     path    string     true        "gateway external ip address"
// @Success 200 "ok"
// @Router /registerGateway/{ns}/{ip} [get]
func (tc *resourceController) _registerGateway(c *gin.Context) {
	ns := c.Param("ns")
	ip := c.Param("ip")
	strIp := registerGateway(clientset, ns, ip)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": strIp})
}
func registerGateway(clientset *kubernetes.Clientset, ns string, ip string) string {

	// https://stackoverflow.com/questions/70345467/how-to-create-config-map-and-secrets-using-golang-kubernetes-api
	// http://blog.johandry.com/post/build-k8s-client/
	// kubectl get configmap game-data -o yaml
	configMapData := make(map[string]string, 0)

	//gatewayEndpoint := `asg.one=34.146.130.74`
	gatewayEndpoint := ip
	/*
		uiProperties := `
				color.good=purple
				color.bad=yellow
				allow.textmode=false
			`
		configMapData["ui.properties"] = uiProperties
	*/
	//configMapData["gateway.endpoints"] = gatewayEndpoints
	configMapData["gateway.endpoint"] = gatewayEndpoint
	configMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "gateway-data",
			Namespace: ns,
		},
		Data: configMapData,
	}

	var cm *corev1.ConfigMap
	if _, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), "gateway-data", metav1.GetOptions{}); errors.IsNotFound(err) {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Update(context.TODO(), &configMap, metav1.UpdateOptions{})
	}
	//https://stackoverflow.com/questions/27545270/how-to-get-a-value-from-map
	log.Printf("Registered in configmap: gateway %+v\n", cm.Data["gateway.endpoint"])
	str := fmt.Sprintf("%+v", cm.Data["gateway.endpoint"])
	return str
}

// @Summary discoverGateway
// @Description discoverGateway
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Success 200 "ok"
// @Router /discoverGateway/{ns} [get]
func (tc *resourceController) _discoverGateway(c *gin.Context) {
	ns := c.Param("ns")
	ips := discoverGateway(clientset, ns)
	ports := rs.getGatewayPort(ic, ns)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "http://" + ips[0] + ":" + ports[0]})
}
func discoverGateway(clientset *kubernetes.Clientset, ns string) []string {
	var arr []string
	var cm *corev1.ConfigMap
	cm, _ = clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), "gateway-data", metav1.GetOptions{})
	log.Printf("Registered in configmap: gateway %+v\n", cm.Data["gateway.endpoint"])
	str := fmt.Sprintf("%+v", cm.Data["gateway.endpoint"])
	arr = append(arr, str)
	return arr
}

// https://pizi.netlify.app/posts/kubernetes-client-go-example/#node%E3%81%AE%E5%8F%96%E5%BE%97
//func discoverNodes(clientset *kubernetes.Clientset) []string {
func discoverNodes() {
	// https://godoc.org/k8s.io/client-go/kubernetes/typed/core/v1
	nodes, err := clientset.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get nodes:", err)
	}

	for i, node := range nodes.Items {
		fmt.Printf("[%d] %s\n", i, node.GetName())
	}
	nodeip := []corev1.NodeAddress{}
	for i := 0; i < len(nodes.Items); i++ {
		nodeip = nodes.Items[i].Status.Addresses
		fmt.Println(nodeip[0].Address)
	}
	fmt.Println(nodes.Items[0].Status.Addresses)

}

// @Summary getGatewayPort
// @Description getGatewayPort
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Success 200 "ok"
// @Router /getGatewayPort/{ns} [get]
func (tc *resourceController) _getGatewayPort(c *gin.Context) {
	ns := c.Param("ns")
	rs.getGatewayPort(ic, ns)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
func (rs *resourceService) getGatewayPort(ic *versioned.Clientset, ns string) []string { // because gateway is exposed as nodePort service
	var arr []string
	// Test VirtualServices
	vsList, err := ic.NetworkingV1alpha3().VirtualServices(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalf("Failed to get VirtualService in %s namespace: %s", ns, err)
	}

	for i := range vsList.Items {
		vs := vsList.Items[i]
		log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.GetHosts())
		//log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.Http[0].Match[0].Uri)
		for j := range vs.Spec.Http {
			log.Printf("[%d] Service Name: %+v, Uri: %+v\n", j, vs.Spec.Http[j].Route[0].Destination.Host, vs.Spec.Http[j].Match[0].Uri)
		}
	}

	// Test DestinationRules
	drList, err := ic.NetworkingV1alpha3().DestinationRules(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalf("Failed to get DestinationRule in %s namespace: %s", ns, err)
	}

	for i := range drList.Items {
		dr := drList.Items[i]
		log.Printf("Index: %d DestinationRule Host: %+v\n", i, dr.Spec.GetHost())
	}

	// Test Gateway
	gwList, err := ic.NetworkingV1alpha3().Gateways(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalf("Failed to get Gateway in %s namespace: %s", ns, err)
	}

	for i := range gwList.Items {
		gw := gwList.Items[i]
		vs := vsList.Items[i]
		for _, s := range gw.Spec.GetServers() {
			//log.Printf("Index: %d Gateway servers: %+v\n", i, s.GetPort().Number)
			log.Printf("http://%+v:%+v\n", vs.Spec.GetHosts()[0], s.GetPort().Number)
			//str := fmt.Sprintf("http://%+v:%+v", vs.Spec.GetHosts()[0], s.GetPort().Number)
			str := fmt.Sprintf("%+v", s.GetPort().Number)
			arr = append(arr, str)
		}
	}
	return arr
}

// @Summary addServiceApidocUrl
// @Description addServiceApidocUrl
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   apidocurl     path    string     true        "api document url"
// @Success 200 "ok"
// @Router /addServiceApidocUrl/{ns}/{svcname}/{apidocurl} [get]
func (tc *resourceController) _addServiceApidocUrl(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	apidocurl := c.Param("apidocurl")
	addServiceApidocUrl(ic, ns, svcname, apidocurl)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}

func addServiceApidocUrl(ic *versioned.Clientset, ns string, svcname string, apidocurl string) map[string]string {
	// https://stackoverflow.com/questions/70345467/how-to-create-config-map-and-secrets-using-golang-kubernetes-api
	// http://blog.johandry.com/post/build-k8s-client/
	// kubectl get configmap game-data -o yaml
	configMapData := make(map[string]string, 0)

	apidocUrl := apidocurl
	configMapData[svcname+".apidocurl"] = apidocUrl
	configMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      svcname + "-apidocurl",
			Namespace: ns,
		},
		Data: configMapData,
	}

	var cm *corev1.ConfigMap
	if _, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), svcname+"-apidocurl", metav1.GetOptions{}); errors.IsNotFound(err) {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Update(context.TODO(), &configMap, metav1.UpdateOptions{})
	}
	//https://stackoverflow.com/questions/27545270/how-to-get-a-value-from-map
	log.Printf("Registered in configmap: %s-apidocurl: %+v\n", svcname, cm.Data[svcname+".apidocurl"])
	//str := fmt.Sprintf("%+v", cm.Data[svcname+".apidocurl"])
	return map[string]string{svcname: apidocurl}
}

// @Summary discoverServiceApidocUrl
// @Description discoverServiceApidocUrl
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /discoverServiceApidocUrl/{ns}/{svcname} [get]
func (tc *resourceController) _discoverServiceApidocUrl(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	str := discoverServiceApidocUrl(clientset, ns, svcname)
	//c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
	c.IndentedJSON(http.StatusOK, gin.H{svcname + ".apidocurl": str})
}
func discoverServiceApidocUrl(clientset *kubernetes.Clientset, ns string, svcname string) string {
	var cm *corev1.ConfigMap
	cm, _ = clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), svcname+"-apidocurl", metav1.GetOptions{})
	log.Printf("found configmap: %s-apidocurl: %+v\n", svcname, cm.Data[svcname+".apidocurl"])
	str := fmt.Sprintf("%+v", cm.Data[svcname+".apidocurl"])
	return str
}

type JSONPatch struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}
type JSONPatchList []*JSONPatch

func AddJsonPatch(jps ...*JSONPatch) JSONPatchList {
	list := make([]*JSONPatch, len(jps))
	for index, jp := range jps {
		list[index] = jp
	}
	return list
}

/*
// @Summary registerService
// @Description registerService
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /registerService/{ns}/{svcname} [get]
func _registerService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	//  /registerService/{ns}/{vsname}/{uriName}/{uriPrefix}/{uriRewrite}/{host}/{port} [get]
	//vsname := c.Param("vsname")
	//uriName := c.Param("uriName")
	//uriPrefix := c.Param("uriPrefix")
	//uriRewrite := c.Param("uriRewrite")
	//host := c.Param("host")
	//port := c.Param("port")
	service, err := clientset.CoreV1().Services(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got service: %+v\n", service.GetName())
	log.Printf("GOt service port: %+v\n", service.Spec.Ports[0].Port)
	//i64Port, _ := strconv.ParseInt(port, 10, 16)
	port := service.Spec.Ports[0].Port
	//registerService(dc, ns, vsname, uriName, uriPrefix, uriRewrite, host, int32(i64Port))
	registerService(dc, ns, svcname, svcname, "/"+svcname, "/", svcname+"."+ns+".svc.cluster.local", port)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
*/

// @Summary registerService
// @Description registerService
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /registerService/{ns}/{svcname} [get]
func (tc *resourceController) _registerService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	service, err := clientset.CoreV1().Services(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got service: %+v\n", service.GetName())
	log.Printf("Got service port: %+v\n", service.Spec.Ports[0].Port)
	port := service.Spec.Ports[0].Port
	registerService(dc, ns, "vs-customer-gateway", svcname, "/"+svcname+"-asg/", "/", svcname+"."+ns+".svc.cluster.local", port)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "/" + svcname + "-asg"})
}
func registerService(dc dynamic.Interface, ns string, vsname string, uriName string, uriPrefix string, uriRewrite string, host string, port int32) {
	//  Create a GVR which represents an Istio Virtual Service.
	gvr := schema.GroupVersionResource{
		Group:    "networking.istio.io",
		Version:  "v1alpha3",
		Resource: "virtualservices",
	}
	_, err := dc.Resource(gvr).Namespace("default").Get(context.TODO(), vsname, metav1.GetOptions{})
	//res, err := dc.Resource(gvr).Namespace("default").Get(context.TODO(), vsname, metav1.GetOptions{})
	//log.Print(res)
	if err != nil {
		log.Print(err)
	}

	list := AddJsonPatch(
		&JSONPatch{
			Op:   "add",
			Path: "/spec/http/-",
			Value: map[string]interface{}{
				"name": host,
				"match": []map[string]interface{}{
					{
						"uri": map[string]interface{}{
							"prefix": uriPrefix,
						},
					},
				},
				"rewrite": map[string]interface{}{
					"uri": uriRewrite,
				},
				"route": []map[string]interface{}{
					{
						"destination": map[string]interface{}{
							"host": host,
							"port": map[string]interface{}{
								"number": port,
							},
						},
					},
				},
			},
		})
	b, _ := json.Marshal(list)
	//  Apply the patch to the service.
	uvs, err := dc.Resource(gvr).Namespace("default").Patch(context.TODO(), vsname, types.JSONPatchType, b, metav1.PatchOptions{})

	httpSlice, _, _ := unstructured.NestedSlice(uvs.Object, "spec", "http")
	//fmt.Printf("Read http slice %+v\n", httpSlice[0]) //returns []interface{}, NOT map[string]interface{} map[match:[map[uri:map[prefix:/detail-asg/]]] name:detail.default.svc.cluster.local rewrite:map[uri:/] route:[map[destination:map[host:detail.default.svc.cluster.local port:map[number:3006]]]]]
	for i, v := range httpSlice { //
		fmt.Println(i, v)
	}

	// marshal unstructed into indented json
	// pass unstructured, NOT unstructed.Object
	jRead, _ := uvs.MarshalJSON()
	var buf bytes.Buffer
	err = json.Indent(&buf, []byte(jRead), "", "  ")
	if err != nil {
		panic(err)
	}
	//indentJson := buf.String()
	//fmt.Printf("indentJson %s/\n", indentJson)

	if err != nil {
		log.Print(err)
	}
}

// @Summary discoverServices
// @Description discoverServices
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Success 200 "ok"
// @Router /discoverServices/{ns} [get]
func (tc *resourceController) _discoverServices(c *gin.Context) {
	ns := c.Param("ns")

	c.IndentedJSON(http.StatusOK, rs.discoverServices(clientset, ns))
}
func (rs *resourceService) discoverServices(clientset *kubernetes.Clientset, ns string) []string {
	services, err := clientset.CoreV1().Services(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get services:", err)
	}
	var arr []string
	for _, svc := range services.Items {
		//fmt.Printf("[%d] %s\n", i, svc.GetName())
		arr = append(arr, svc.GetName())
	}
	return arr
}

// @Summary discoverService
// @Description discoverService
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /discoverService/{ns}/{svcname} [get]
func (tc *resourceController) _discoverService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")

	invokingPath := discoverService(clientset, ns, svcname)
	c.IndentedJSON(http.StatusOK, gin.H{"path": invokingPath})
}
func discoverService(clientset *kubernetes.Clientset, ns string, svcname string) string {

	service, err := clientset.CoreV1().Services(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got service: %+v\n", service.GetName())
	str := fmt.Sprintf("/%+v-asg", service.GetName())
	return str
}

// postLBConfig
// @Summary
// @Tags Istio Resouce Config
// @Accept  json
// @Produce  json
// @Param data body lb true "new LB policy to apply to service"
// @Success 200
// @Failure 400
// @Router /api/icg/lbConfig [post]

// @Summary circuitBreaker
// @Description circuitBreaker defines circuit breaker policy that applies to traffic intended for a service after routing has occurred.
// @tags traffic governance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /circuitBreaker/{ns}/{svcname} [get]
func (tc *resourceController) _circuitBreaker(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	circuitBreaker(ic, ns, svcname)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
func circuitBreaker(ic *versioned.Clientset, ns string, svcname string) {

	// delete existing dr
	ic.NetworkingV1alpha3().DestinationRules(ns).Delete(context.TODO(), "dr-detail", v1.DeleteOptions{})

	var (
		destinationRule *v1alpha3.DestinationRule
	)

	destinationRule = &v1alpha3.DestinationRule{
		TypeMeta: v1.TypeMeta{},
		ObjectMeta: v1.ObjectMeta{
			Namespace: ns,
			Name:      "dr-" + svcname,
		},
		Spec: networkingv1alpha3.DestinationRule{
			Host: svcname,
			TrafficPolicy: &networkingv1alpha3.TrafficPolicy{
				LoadBalancer: &networkingv1alpha3.LoadBalancerSettings{
					LbPolicy: &networkingv1alpha3.LoadBalancerSettings_Simple{
						Simple: networkingv1alpha3.LoadBalancerSettings_SimpleLB(4), //networkingv1alpha3.LoadBalancerSettings_PASSTHROUGH, Lb      int32  `json:"lb" example:"4"` // round-robin
					},
					LocalityLbSetting: nil,
				},
				//
				ConnectionPool: &networkingv1alpha3.ConnectionPoolSettings{
					Tcp: &networkingv1alpha3.ConnectionPoolSettings_TCPSettings{
						// Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.
						MaxConnections: 200,
						// TCP connection timeout. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
						ConnectTimeout: nil,
					},
					Http: &networkingv1alpha3.ConnectionPoolSettings_HTTPSettings{
						// Maximum number of pending HTTP requests to a destination. Default 2^32-1.
						// 最大请求数
						Http1MaxPendingRequests: 200,
						// Maximum number of requests to a backend. Default 2^32-1.
						// 每个后端最大请求数
						Http2MaxRequests: 20,
						// Maximum number of requests per connection to a backend. Setting this
						// parameter to 1 disables keep alive. Default 0, meaning "unlimited",
						// up to 2^29.
						// 是否启用keepalive对后端进行长链接 0 表示启用
						MaxRequestsPerConnection: 0,
						// Maximum number of retries that can be outstanding to all hosts in a
						// cluster at a given time. Defaults to 2^32-1.
						// 在给定时间内最大的重试次数
						MaxRetries: 1,
						// The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests.
						// If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed.
						// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.
						// 不设置默认1小时没有请求，断开后端连接
						IdleTimeout: nil,
						// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
						//H2UpgradePolicy:          0,
					},
				},
				//
				// 类似nginx的 next upstream
				//OutlierDetection:     nil,
				//Tls:                  nil,
				//PortLevelSettings: nil,
			},
		},
	}
	dr, err := ic.NetworkingV1alpha3().DestinationRules(ns).Create(context.TODO(), destinationRule, v1.CreateOptions{})
	if err != nil {
		log.Print(err)
		return
	}
	log.Print(dr)
}

// http://localhost:8080/invokeServiceEndpoint?method=get&path=/api/hello&svcname=detail&endpointurl=http://123.456.7.8/api/list
// https://qiita.com/taizo/items/c397dbfed7215969b0a5
// HTTPリクエストのレスポンスを構造体定義なしでjsonに吐き出す方法
// https://shiimanblog.com/engineering/output-json/
func (tc *resourceController) _invokeServiceEndpointt(c *gin.Context) {
	//invokeServiceEndpoint()
	fmt.Printf("%+v", c.Request.URL.Query()["svcname"])
	fmt.Printf("%+v", c.Request.URL.Query()["method"])
	fmt.Printf("%+v", c.Request.URL.Query()["endpointurl"]) //http://123.456.7.8/api/list
	url := "http://34.146.130.74:31401/detail-asg/detail/111"
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("Authorization", "Bearer access-token")

	// request header
	dump, _ := httputil.DumpRequestOut(req, true)
	fmt.Printf("%s", dump)

	client := new(http.Client)
	resp, _ := client.Do(req)

	// response header
	dumpResp, _ := httputil.DumpResponse(resp, true)
	fmt.Printf("%s", dumpResp)

	// response body
	defer resp.Body.Close()
	body, _ := io.ReadAll(resp.Body)
	// JSONを構造体にエンコード
	var response interface{}
	json.Unmarshal(body, &response)
	c.IndentedJSON(http.StatusOK, response)
}

// http://localhost:8080/invokeService/default/detail?path=/detail/111
// @Summary invokeService
// @Description invokeService
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   path     query    string     true        "service path (ex. /path)"
// @Success 200 "ok"
// @Router /invokeService/{ns}/{svcname} [get]
func (tc *resourceController) _invokeService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	fmt.Printf("URL: %+v\n", c.Query("path")) //http://123.456.7.8/api/list
	//url := "http://34.146.130.74:31401/detail-asg/detail/111"
	path := fmt.Sprintf("%s", c.Query("path"))
	c.IndentedJSON(http.StatusOK, invokeService(ns, svcname, path))
}
func invokeService(ns string, svcname string, path string) interface{} {

	// get gateway address
	addrs := rs.getGatewayAddrs(clientset)
	ports := rs.getGatewayPort(ic, "default")
	fmt.Printf("gwAddrsPorts\n%+v\n%+v\n", addrs, ports)
	addr := addrs[0]
	port := ports[0]
	svcpath := discoverService(clientset, ns, svcname)
	url := "http://" + addr + ":" + port + svcpath + path
	fmt.Printf("Service Invoking Url: %+v\n", url)

	req, _ := http.NewRequest("GET", url, nil)
	//req.Header.Set("Authorization", "Bearer access-token")

	// request header
	dump, _ := httputil.DumpRequestOut(req, true)
	fmt.Printf("%s", dump)

	client := new(http.Client)
	resp, _ := client.Do(req)

	// response header
	//dumpResp, _ := httputil.DumpResponse(resp, true)
	//fmt.Printf("%s", dumpResp)

	// response body
	defer resp.Body.Close()
	body, _ := io.ReadAll(resp.Body)
	// JSONを構造体にエンコード
	var response interface{}
	json.Unmarshal(body, &response)
	return response
}

// http://localhost:8080/invokeServiceEndpoint?method=get&path=/api/hello&svcname=detail&endpointurl=http://123.456.7.8/api/list
// https://qiita.com/taizo/items/c397dbfed7215969b0a5
// HTTPリクエストのレスポンスを構造体定義なしでjsonに吐き出す方法
// https://shiimanblog.com/engineering/output-json/
// @Summary invokeServiceEndpoint
// @Description invokeServiceEndpoint
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   endpointurl     query    string     true        "endpoint url (ex. http://POD_IP:PORT/path)"
// @Success 200 "ok"
// @Router /invokeServiceEndpoint [get]
func (tc *resourceController) _invokeServiceEndpoint(c *gin.Context) {
	//fmt.Printf("%+v", c.Request.URL.Query()["svcname"])
	//fmt.Printf("%+v", c.Request.URL.Query()["method"])
	fmt.Printf("URL: %+v\n", c.Query("endpointurl")) //http://123.456.7.8/api/list
	//url := "http://34.146.130.74:31401/detail-asg/detail/111"
	url := fmt.Sprintf("%s", c.Query("endpointurl"))
	c.IndentedJSON(http.StatusOK, invokeServiceEndpoint(url))
}
func invokeServiceEndpoint(url string) interface{} {
	req, _ := http.NewRequest("GET", url, nil)
	//req.Header.Set("Authorization", "Bearer access-token")

	// request header
	dump, _ := httputil.DumpRequestOut(req, true)
	fmt.Printf("%s", dump)

	client := new(http.Client)
	resp, _ := client.Do(req)

	// response header
	//dumpResp, _ := httputil.DumpResponse(resp, true)
	//fmt.Printf("%s", dumpResp)

	// response body
	defer resp.Body.Close()
	body, _ := io.ReadAll(resp.Body)
	// JSONを構造体にエンコード
	var response interface{}
	json.Unmarshal(body, &response)
	return response
}

// @Summary discoverServiceEndpoints
// @Description discoverServiceEndpoints
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /discoverServiceEndpoints/{ns}/{svcname} [get]
func (tc *resourceController) _discoverServiceEndpoints(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	c.IndentedJSON(http.StatusOK, discoverServiceEndpoints(clientset, ns, svcname))
}

//func discoverServiceEndpoints(clientset *kubernetes.Clientset, ns string, svcname string) *corev1.Endpoints.EndpointSubset {
func discoverServiceEndpoints(clientset *kubernetes.Clientset, ns string, svcname string) []corev1.EndpointSubset {
	//kubectl get ep detail
	/*
		service, err := clientset.CoreV1().Services("default").Get(context.TODO(), "detail", metav1.GetOptions{})
		if err != nil {
			log.Fatalln("failed to get service:", err)
		}
		log.Printf("Got service: %+v\n", service.GetName())
		str := fmt.Sprintf("/%+v-asg", service.GetName())
		log.Printf("Got str: %+v\n", str)
	*/
	endpoints, err := clientset.CoreV1().Endpoints("default").Get(context.TODO(), "detail", metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got endpoints. addresses: %+v, ports: %+v\n", endpoints.Subsets[0].Addresses, endpoints.Subsets[0].Ports[0])
	var addrs []string
	for _, addr := range endpoints.Subsets[0].Addresses {
		addrs = append(addrs, addr.IP)
	}

	fmt.Printf("addrs: %s, port: %d\n", addrs, endpoints.Subsets[0].Ports[0].Port)
	return endpoints.Subsets
}

// @Summary discoverServiceEndpoints
// @Description discoverServiceEndpoints
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   ns     path    string     true        "nodename"
// @Success 200 "ok"
// @Router /discoverServiceEndpoints/{ns}/{svcname}/{nodename} [get]
func (tc *resourceController) _discoverServiceEndpointsInNode(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	nodename := c.Param("nodename")
	c.IndentedJSON(http.StatusOK, discoverServiceEndpointsInNode(clientset, ns, svcname, nodename))
}
func discoverServiceEndpointsInNode(clientset *kubernetes.Clientset, ns string, svcname string, nodename string) corev1.EndpointSubset {
	//kubectl get ep detail
	/*
		service, err := clientset.CoreV1().Services("default").Get(context.TODO(), "detail", metav1.GetOptions{})
		if err != nil {
			log.Fatalln("failed to get service:", err)
		}
		log.Printf("Got service: %+v\n", service.GetName())
		str := fmt.Sprintf("/%+v-asg", service.GetName())
		log.Printf("Got str: %+v\n", str)
	*/

	endpoints, err := clientset.CoreV1().Endpoints("default").Get(context.TODO(), "detail", metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got endpoints. addresses: %+v, ports: %+v\n", endpoints.Subsets[0].Addresses, endpoints.Subsets[0].Ports[0])
	var addrs []string
	for _, addr := range endpoints.Subsets[0].Addresses {
		addrs = append(addrs, addr.IP)
	}

	// アドレスはポートごとに異なるサブセットで表示されます。
	// サービスを構成するアドレスとポートのセット。
	// EndpointSubsetは、共通のポートセットを持つアドレスのグループです。
	var addresses []corev1.EndpointAddress
	for _, addr := range endpoints.Subsets[0].Addresses {
		if *addr.NodeName == nodename {
			addresses = append(addresses, addr)
		}

	}
	var endpointSubset corev1.EndpointSubset
	endpointSubset.Addresses = addresses
	endpointSubset.Ports = endpoints.Subsets[0].Ports

	fmt.Printf("endpoints in node %s:\n%+v\n", nodename, endpointSubset)
	return endpointSubset
}

// @Summary invokeServiceEndpointsInNode
// @Description invokeServiceEndpointsInNode
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   frontid     path    string     true        "front ID"
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   path     query    string     true        "path (ex. /path)"
// @Success 200 "ok"
// @Router /invokeServiceEndpointsInNode/{frontid}/{ns}/{svcname} [get]
func (tc *resourceController) _invokeServiceEndpointsInNode(c *gin.Context) {
	frontid := c.Param("frontid")
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	path := c.Query("path")
	fmt.Printf("path: %+v\n", c.Query("path")) // /api/list

	c.IndentedJSON(http.StatusOK, invokeServiceEndpointsInNode(clientset, frontid, ns, svcname, path))
}

//func invokeServiceEndpointsInNode(clientset *kubernetes.Clientset, ns string, svcname string, frontid string) corev1.EndpointSubset {
func invokeServiceEndpointsInNode(clientset *kubernetes.Clientset, frontid string, ns string, svcname string, path string) interface{} { // return JSON
	//kubectl get ep detail
	/*
		service, err := clientset.CoreV1().Services("default").Get(context.TODO(), "detail", metav1.GetOptions{})
		if err != nil {
			log.Fatalln("failed to get service:", err)
		}
		log.Printf("Got service: %+v\n", service.GetName())
		str := fmt.Sprintf("/%+v-asg", service.GetName())
		log.Printf("Got str: %+v\n", str)
	*/

	// search config first!! if not found, route to all nodes
	//
	naming := frontid + "." + svcname + ".routenode"

	var nodename string = ""
	if cm, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), naming, metav1.GetOptions{}); errors.IsNotFound(err) {
		// no routing node specified, route to any arbitrary node's endpoint pod
		log.Printf("no routing node specified, route to any arbitrary node's endpoint pod\n")
	} else {
		// routing node found
		log.Printf("Routing node found: %s: %+v\n", naming, cm.Data[naming])
		nodename = cm.Data[naming]
	}

	endpoints, err := clientset.CoreV1().Endpoints(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got endpoints. addresses: %+v, ports: %+v\n", endpoints.Subsets[0].Addresses, endpoints.Subsets[0].Ports[0])
	var addrs []string
	for _, addr := range endpoints.Subsets[0].Addresses {
		addrs = append(addrs, addr.IP)
	}

	var addresses []corev1.EndpointAddress
	if nodename != "" { // nodename node's pods
		for _, addr := range endpoints.Subsets[0].Addresses {
			if *addr.NodeName == nodename {
				addresses = append(addresses, addr)
			}
		}
	} else { // arbitrary node's pods
		for _, addr := range endpoints.Subsets[0].Addresses {
			addresses = append(addresses, addr)
		}
	}

	var endpointSubset corev1.EndpointSubset
	endpointSubset.Addresses = addresses
	endpointSubset.Ports = endpoints.Subsets[0].Ports

	fmt.Printf("endpoints in node %s:\n%+v\n", nodename, endpointSubset)
	fmt.Printf("URL: http://%s:%d%s", endpointSubset.Addresses[0].IP, endpointSubset.Ports[0].Port, path)
	//url := fmt.Sprintf("http://%s:%s%s", endpointSubset.Addresses[0].IP, endpointSubset.Ports[0].Port, path)
	//return endpointSubset
	var response interface{} // = invokeServiceEndpoint(url)
	//var response interface{} = invokeServiceEndpoint("http://34.146.130.74:31941/test/111")
	return response
}

// @Summary invokeServiceEndpointsByIps
// @Description invokeServiceEndpointsByIps
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   frontid     path    string     true        "front ID"
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /invokeServiceEndpointsByIps/{frontid}/{ns}/{svcname} [get]
func (tc *resourceController) _invokeServiceEndpointsByIps(c *gin.Context) {
	frontid := c.Param("frontid")
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	path := c.Query("path")
	fmt.Printf("path: %+v\n", c.Query("path")) // /api/list

	c.IndentedJSON(http.StatusOK, invokeServiceEndpointsByIps(clientset, frontid, ns, svcname, path))
}
func invokeServiceEndpointsByIps(clientset *kubernetes.Clientset, frontid string, ns string, svcname string, path string) interface{} { // return JSON
	//kubectl get ep detail
	/*
		service, err := clientset.CoreV1().Services("default").Get(context.TODO(), "detail", metav1.GetOptions{})
		if err != nil {
			log.Fatalln("failed to get service:", err)
		}
		log.Printf("Got service: %+v\n", service.GetName())
		str := fmt.Sprintf("/%+v-asg", service.GetName())
		log.Printf("Got str: %+v\n", str)
	*/

	// search config first!! if not found, route to all nodes
	//
	naming := frontid + "." + svcname + ".routeip"

	var ips_found bool = false
	var ips []string
	if cm, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), naming, metav1.GetOptions{}); errors.IsNotFound(err) {
		// no routing node specified, route to any arbitrary node's endpoint pod
		log.Printf("no routing node specified, route to any arbitrary node's endpoint pod\n")
	} else {
		// routing node found
		log.Printf("Routing node found: %s: %+v\n", naming, cm.Data[naming])
		ips = strings.Split(cm.Data[naming], ",")
		ips_found = true
		fmt.Printf("%Endpoint IPs' array: +v\n", ips)
	}

	endpoints, err := clientset.CoreV1().Endpoints(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got endpoints. addresses: %+v, ports: %+v\n", endpoints.Subsets[0].Addresses, endpoints.Subsets[0].Ports[0])
	var addrs []string
	for _, addr := range endpoints.Subsets[0].Addresses {
		addrs = append(addrs, addr.IP)
	}

	var addresses []corev1.EndpointAddress
	if ips_found != true { // ip is in saved cofig
		for _, addr := range endpoints.Subsets[0].Addresses {
			if addr.IP == ips[0] {
				addresses = append(addresses, addr)
			}
		}
	} else { // arbitrary endpoint ip's pods
		for _, addr := range endpoints.Subsets[0].Addresses {
			addresses = append(addresses, addr)
		}
	}

	var endpointSubset corev1.EndpointSubset
	endpointSubset.Addresses = addresses
	endpointSubset.Ports = endpoints.Subsets[0].Ports

	fmt.Printf("endpoints in saved config %+v:\n%+v\n", ips, endpointSubset)
	fmt.Printf("URL: http://%s:%d%s", endpointSubset.Addresses[0].IP, endpointSubset.Ports[0].Port, path)
	//url := fmt.Sprintf("http://%s:%s%s", endpointSubset.Addresses[0].IP, endpointSubset.Ports[0].Port, path)
	//return endpointSubset
	var response interface{} // = invokeServiceEndpoint(url)
	//var response interface{} = invokeServiceEndpoint("http://34.146.130.74:31941/test/111")
	return response
}

// @Summary /addFrontEpNodeRoute
// @Description /addFrontEpNodeRoute
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   frontid     path    string     true        "front client ID "
// @Param   nodename     path    string     true        "node name"
// @Success 200 "ok"
// @Router /addFrontEpNodeRoute/{ns}/{svcname}/{frontid}/{nodename} [get]
func (tc *resourceController) _addFrontEpNodeRoute(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	frontid := c.Param("frontid")
	nodename := c.Param("nodename")
	addFrontEpNodeRoute(ic, ns, svcname, frontid, nodename)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}

func addFrontEpNodeRoute(ic *versioned.Clientset, ns string, svcname string, frontid string, nodename string) map[string]string {
	// https://stackoverflow.com/questions/70345467/how-to-create-config-map-and-secrets-using-golang-kubernetes-api
	// http://blog.johandry.com/post/build-k8s-client/
	// kubectl get configmap game-data -o yaml
	configMapData := make(map[string]string, 0)

	naming := frontid + "." + svcname + ".routenode"

	configMapData[naming] = nodename
	configMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      naming,
			Namespace: ns,
		},
		Data: configMapData,
	}

	var cm *corev1.ConfigMap
	if _, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), naming, metav1.GetOptions{}); errors.IsNotFound(err) {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Update(context.TODO(), &configMap, metav1.UpdateOptions{})
	}
	//https://stackoverflow.com/questions/27545270/how-to-get-a-value-from-map
	log.Printf("Registered in configmap: %s: %+v\n", naming, cm.Data[naming])
	//str := fmt.Sprintf("%+v", cm.Data[svcname+".apidocurl"])
	return map[string]string{naming: cm.Data[naming]}
}

// @Summary /addFrontEpNodeRoute
// @Description /addFrontEpNodeRoute
// @tags serviceGovernance
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   frontid     path    string     true        "front client ID "
// @Param   ips     path    string     true        "endpoint IP addresses"
// @Success 200 "ok"
// @Router /addFrontEpNodeRoute/{ns}/{svcname}/{frontid}/{ips} [get]
func (tc *resourceController) _addFrontEpIpsRoute(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	frontid := c.Param("frontid")
	ips := c.Param("ips")
	addFrontEpIpsRoute(ic, ns, svcname, frontid, ips)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}

func addFrontEpIpsRoute(ic *versioned.Clientset, ns string, svcname string, frontid string, ips string) map[string]string {
	// https://stackoverflow.com/questions/70345467/how-to-create-config-map-and-secrets-using-golang-kubernetes-api
	// http://blog.johandry.com/post/build-k8s-client/
	// kubectl get configmap game-data -o yaml
	configMapData := make(map[string]string, 0)

	//arr := strings.Split(ips, ",")
	//fmt.Printf("%+v\n", arr)
	//fmt.Printf("%+v\n", strings.Join(arr, ", "))

	naming := frontid + "." + svcname + ".routeip"

	configMapData[naming] = ips
	configMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      naming,
			Namespace: ns,
		},
		Data: configMapData,
	}

	var cm *corev1.ConfigMap
	if _, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), naming, metav1.GetOptions{}); errors.IsNotFound(err) {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Update(context.TODO(), &configMap, metav1.UpdateOptions{})
	}
	//https://stackoverflow.com/questions/27545270/how-to-get-a-value-from-map
	log.Printf("Registered in configmap: %s: %+v\n", naming, cm.Data[naming])
	//str := fmt.Sprintf("%+v", cm.Data[svcname+".apidocurl"])
	return map[string]string{naming: cm.Data[naming]}
}

// @description テスト用APIの詳細
// @version 1.0
// @accept application/x-json-stream
// @param none query string false "必須ではありません。"
// @Success 200
// @router /test/{id} [get]
func getTest(c *gin.Context) {
	id := c.Param("id")
	str := id //"赤,黄,青"
	arr := strings.Split(str, ",")
	fmt.Printf("%+v\n", arr)
	fmt.Printf("%+v\n", strings.Join(arr, ", "))

	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}

var clientset *kubernetes.Clientset
var dc dynamic.Interface
var ic *versioned.Clientset

// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run main.go

// swagger doc how to write
// https://moneyforward.com/engineers_blog/2021/10/20/go-api-swagger/
// https://qiita.com/Syoitu/items/71ca216c271e2d3c14ca
// https://github.com/swaggo/gin-swagger/tree/master/example/basic/api

// @title SGME API
// @version 1.0

// @host 0.0.0.0:8080
// @BasePath /

// @tag.name serviceGovernance
// @tag.description service registration/discovery/routing
// @tag.name traffic governance
// @tag.description traffic managemenet
func main() {

	kubeconfig := os.Getenv("KUBECONFIG")
	namespace := os.Getenv("NAMESPACE")

	if len(kubeconfig) == 0 || len(namespace) == 0 {
		log.Fatalf("Environment variables KUBECONFIG and NAMESPACE need to be set")
	}

	restConfig, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		log.Fatalf("Failed to create k8s rest client: %s", err)
	}

	clientset, err = kubernetes.NewForConfig(restConfig)
	if err != nil {
		log.Fatal(err)
	}

	dc, err = dynamic.NewForConfig(restConfig)
	if err != nil {
		panic(err.Error())
	}
	//addNewMsRouteToVs(dynamicClient, "default", "vs-customer-gateway", "uriName", "/uriprefixaa", "/uriRewrteaa", "svc-c.default.svc.cluster.local", 5000)

	/*
		// Get a resource (returns an unstructured object).
		resourceScheme := sigv1alpha3.SchemeBuilder.GroupVersion.WithResource("virtualservices")
		resp, err := dynamicClient.Resource(resourceScheme).Namespace("default").Get(context.TODO(), "vs-customer-gateway", metav1.GetOptions{})
		unstructured := resp.UnstructuredContent()
		var uvslist *v1alpha3.VirtualServiceList
		err = runtime.DefaultUnstructuredConverter.
			FromUnstructured(unstructured, &uvslist)
		if err != nil {
			panic(err)
		}
		fmt.Println(uvslist.Items)
	*/
	//addNewMsRouteToVs(dynamicClient, "default", "vs-customer-gateway", "uriName", "/uriprefixaa", "/uriRewrteaa", "svc-c.default.svc.cluster.local", 5000)

	//log.Printf(" %+v\n", registerGatewayIP(clientset, "default", "34.146.130.74"))
	/*
		//services, err := clientset.CoreV1().Services("").List(context.TODO(), metav1.ListOptions{}) // list services in all namespace
		services, err := clientset.CoreV1().Services("default").List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalln("failed to get services:", err)
		}
		for i, svc := range services.Items {
			fmt.Printf("[%d] %s\n", i, svc.GetName())
		}
	*/

	ic, err = versionedclient.NewForConfig(restConfig)
	if err != nil {
		log.Fatalf("Failed to create istio client: %s", err)
	}

	//log.Printf(" %+v\n", listGatewaysInNamespace(ic, "default"))
	/*
		// Test VirtualServices
		vsList, err := ic.NetworkingV1alpha3().VirtualServices(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get VirtualService in %s namespace: %s", namespace, err)
		}

		for i := range vsList.Items {
			vs := vsList.Items[i]
			log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.GetHosts())
			//log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.Http[0].Match[0].Uri)
			for j := range vs.Spec.Http {
				log.Printf("[%d] Service Name: %+v, Uri: %+v\n", j, vs.Spec.Http[j].Route[0].Destination.Host, vs.Spec.Http[j].Match[0].Uri)
			}
		}

		// Test DestinationRules
		drList, err := ic.NetworkingV1alpha3().DestinationRules(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get DestinationRule in %s namespace: %s", namespace, err)
		}

		for i := range drList.Items {
			dr := drList.Items[i]
			log.Printf("Index: %d DestinationRule Host: %+v\n", i, dr.Spec.GetHost())
		}

		// Test Gateway
		gwList, err := ic.NetworkingV1alpha3().Gateways(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get Gateway in %s namespace: %s", namespace, err)
		}

		for i := range gwList.Items {
			gw := gwList.Items[i]
			vs := vsList.Items[i]
			for _, s := range gw.Spec.GetServers() {
				//log.Printf("Index: %d Gateway servers: %+v\n", i, s.GetPort().Number)
				log.Printf("http://%+v:%+v\n", vs.Spec.GetHosts()[0], s.GetPort().Number)
			}
		}

		// Test ServiceEntry
		seList, err := ic.NetworkingV1alpha3().ServiceEntries(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get ServiceEntry in %s namespace: %s", namespace, err)
		}

		for i := range seList.Items {
			se := seList.Items[i]
			for _, h := range se.Spec.GetHosts() {
				log.Printf("Index: %d ServiceEntry hosts: %+v\n", i, h)
			}
		}
	*/

	// -------------------------------------------------------------------
	// Restful API impl.

	router := gin.Default()
	//https://qiita.com/ichi_zamurai/items/97e7e93bf398f98e719e
	//https://github.com/gin-contrib/cors
	router.Use(cors.New(cors.Config{
		// アクセス許可するオリジン
		AllowOrigins: []string{
			"*",
			//"http://localhost:3000", // for frontend SPA client
			//"http://localhost:8080", // for swagger
		},
		// アクセス許可するHTTPメソッド
		AllowMethods: []string{
			//"POST",
			//"GET",
			//"OPTIONS",
			"*",
		},
		// 許可するHTTPリクエストヘッダ
		AllowHeaders: []string{
			//"Access-Control-Allow-Origin",
			"*",
		},
		// cookieなどの情報を必要とするかどうか
		AllowCredentials: false,
	}))

	router.GET("/test/:id", getTest)
	router.GET("/todos", rc.GetTodos)
	router.GET("/registerGateway/:ns/:ip", rc._registerGateway)
	router.GET("/discoverGateway/:ns", rc._discoverGateway)
	router.GET("/getGatewayPort/:ns", rc._getGatewayPort)                               //http://localhost:8080/test/3
	router.GET("/addServiceApidocUrl/:ns/:svcname/:apidocurl", rc._addServiceApidocUrl) // http://localhost:8080/addServiceApidocUrl/default/svcname/apidocurl
	router.GET("/discoverServiceApidocUrl/:ns/:svcname", rc._discoverServiceApidocUrl)
	//router.GET("/registerService/:ns/:vsname/:uriName/:uriPrefix/:uriRewrite/:host/:port", _registerService)
	router.GET("/invokeServiceEndpoint", rc._invokeServiceEndpoint)
	router.GET("/invokeServiceEndpointt", rc._invokeServiceEndpointt)
	router.GET("/discoverServiceEndpoints/:ns/:svcname", rc._discoverServiceEndpoints)
	router.GET("/discoverServiceEndpointsInNode/:ns/:svcname/:nodename", rc._discoverServiceEndpointsInNode)
	router.GET("/addFrontEpNodeRoute/:ns/:svcname/:frontid/:nodename", rc._addFrontEpNodeRoute)
	router.GET("/addFrontEpIpsRoute/:ns/:svcname/:frontid/:nodename", rc._addFrontEpIpsRoute)
	router.GET("/invokeServiceEndpointsInNode/:frontid/:ns/:svcname", rc._invokeServiceEndpointsInNode)
	router.GET("/invokeServiceEndpointsByIps/:frontid/:ns/:svcname", rc._invokeServiceEndpointsByIps)
	router.GET("/getGatewayAddrsAndPorts", rc._getGatewayAddrsAndPorts)
	router.GET("/registerService/:ns/:svcname", rc._registerService)
	router.GET("/discoverService/:ns/:svcname", rc._discoverService)
	router.GET("/discoverServices/:ns", rc._discoverServices)
	router.GET("/invokeService/:ns/:svcname", rc._invokeService) // plus qurey param path needed
	router.GET("/circuitBreaker/:ns/:svcname", rc._circuitBreaker)

	/* IMPORTANT
	router.GET("/addServiceApidocUrl/:ns/:svcname/:apidocurl", _addServiceApidocUrl) // http://localhost:8080/addServiceApidocUrl/default/svcname/apidocurl
	router.GET("/discoverServiceApidocUrl/:ns/:svcname", _discoverServiceApidocUrl)

	router.GET("/registerService/:ns/:svcname", _registerService)
	router.GET("/discoverService/:ns/:svcname", _discoverService)
	router.GET("/discoverServices/:ns", _discoverServices)
	router.GET("/discoverServiceEndpoints/:ns/:svcname", _discoverServiceEndpoints)
	router.GET("/invokeService/:ns/:svcname", _invokeService) // plus qurey param path needed

	router.GET("/addFrontEpNodeRoute/:ns/:svcname/:frontid/:nodename", _addFrontEpNodeRoute)
	router.GET("/addFrontEpIpsRoute/:ns/:svcname/:frontid/:nodename", _addFrontEpIpsRoute)

	router.GET("/invokeServiceEndpointsInNode/:frontid/:ns/:svcname", _invokeServiceEndpointsInNode)
	router.GET("/invokeServiceEndpointsByIps/:frontid/:ns/:svcname", _invokeServiceEndpointsByIps)

	router.GET("/getGatewayAddrsAndPorts", _getGatewayAddrsAndPorts)
	router.GET("/circuitBreaker/:ns/:svcname", _circuitBreaker)
	*/

	//url := ginSwagger.URL("http://localhost:8080/swagger/doc.json")
	//router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// export GO111MODULE=on
	// rm go.mod
	// go mod init
	// go mod tidy
	// swag init
	// go get .
	// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run main.go
	// http://localhost:8080/swagger/index.html
	router.Run("0.0.0.0:8080")

}

// https://vivinko.com/inoue/blog/2021/10/07/154349.html
// petstore example
// docker pull swaggerapi/swagger-editor
// docker run -d -p 8888:8080 swaggerapi/swagger-editor
// swagger2markdown
// docker pull swagger2markup/swagger2markup
// docker run --rm -v $(pwd):/opt swagger2markup/swagger2markup convert -i /opt/swagger.yaml -f /opt/swagger -c /opt/config.properties
// docker run --platform linux/x86_64 --rm -v $(pwd):/opt swagger2markup/swagger2markup convert -i /opt/swagger.yaml -f /opt/swagger -c /opt/config.properties
// docker exec -it sh
// ps

//circuit breaker
/*
	ConnectionPool: &networkingv1alpha3.ConnectionPoolSettings{
		Tcp: &networkingv1alpha3.ConnectionPoolSettings_TCPSettings{
			// Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.
			MaxConnections: 200,
			// TCP connection timeout. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
			ConnectTimeout: nil,
		},
		Http: &networkingv1alpha3.ConnectionPoolSettings_HTTPSettings{
			// Maximum number of pending HTTP requests to a destination. Default 2^32-1.
			// 最大请求数
			Http1MaxPendingRequests: 200,
			// Maximum number of requests to a backend. Default 2^32-1.
			// 每个后端最大请求数
			Http2MaxRequests: 20,
			// Maximum number of requests per connection to a backend. Setting this
			// parameter to 1 disables keep alive. Default 0, meaning "unlimited",
			// up to 2^29.
			// 是否启用keepalive对后端进行长链接 0 表示启用
			MaxRequestsPerConnection: 0,
			// Maximum number of retries that can be outstanding to all hosts in a
			// cluster at a given time. Defaults to 2^32-1.
			// 在给定时间内最大的重试次数
			MaxRetries: 1,
			// The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests.
			// If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed.
			// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.
			// 不设置默认1小时没有请求，断开后端连接
			IdleTimeout: nil,
			// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
			//H2UpgradePolicy:          0,
		},
	},
*/

// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run main.go
// export KUBECONFIG='/root/.kube/config' && export NAMESPACE='default' && go run main.go
// http://localhost:8080/discoverServiceEndpoints/default/detail
// http://34.146.130.74:8088/invokeServiceEndpoint?method=get&path=/api/hello&svcname=detail&endpointurl=http://123.456.7.8/api/list
// export KUBECONFIG='/code/config' && export NAMESPACE='default' && go run main.go

// http://localhost:8080/invokeServiceEndpoint?method=get&path=/api/hello&svcname=detail
// http://localhost:8080/discoverServiceEndpoints/default/detail
// http://34.146.130.74:31941/invokeServiceEndpointt?method=get&path=/api/hello&svcname=detail&endpointurl=http://123.456.7.8/api/list
// http://34.146.130.74:31941/invokeServiceEndpoint?method=get&path=/api/hello&svcname=detail&endpointurl=http://10.42.0.19:3006/detail/111
// http://34.146.130.74:31941/discoverServiceEndpoints/default/detail
// http://34.146.130.74:31941/test/111

// @Summary getGatewayAddrsAndPorts
// @Description getGatewayAddrsAndPorts
// @Accept  json
// @Produce  json
// @Success 200 "ok"
// @Router /getGatewayAddrsAndPorts [get]
func (tc *resourceController) _getGatewayAddrsAndPorts(c *gin.Context) {
	addrs := rs.getGatewayAddrs(clientset)
	ports := rs.getGatewayPort(ic, "default")
	c.IndentedJSON(http.StatusOK, gin.H{"addresses": addrs, "ports": ports}) //  H:htmlに渡す変数を定義
}
func (rs *resourceService) getGatewayAddrs(clientset *kubernetes.Clientset) []string {
	nodes, err := clientset.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get services:", err)
	}

	var arr []string
	for i, node := range nodes.Items {
		fmt.Printf("[%d] %s\n", i, node.GetName())
		for annotation_name, annotation_value := range node.GetAnnotations() {
			if annotation_name == "rke.cattle.io/external-ip" {
				fmt.Println("%+s, %+s\n", annotation_name, annotation_value)
				arr = append(arr, annotation_value)
			}
		}
	}
	return arr
}

// http://localhost:8080/getGatewayAddrsAndPorts

//------------------
var rs = NewResourceService()
var rc = NewResourceController(rs)

//------------------
// 外部パッケージに公開するインタフェース
type ResourceController interface {
	GetTodos(c *gin.Context)
	_registerGateway(c *gin.Context)
	_discoverGateway(c *gin.Context)
	_getGatewayPort(c *gin.Context)
	_addServiceApidocUrl(c *gin.Context)
	_discoverServiceApidocUrl(c *gin.Context)
	_registerService(c *gin.Context)
	_discoverServices(c *gin.Context)
	_discoverService(c *gin.Context)
	_circuitBreaker(c *gin.Context)
	_invokeServiceEndpointt(c *gin.Context)
	_invokeService(c *gin.Context)
	_invokeServiceEndpoint(c *gin.Context)
	_discoverServiceEndpoints(c *gin.Context)
	_discoverServiceEndpointsInNode(c *gin.Context)
	_invokeServiceEndpointsInNode(c *gin.Context)
	_invokeServiceEndpointsByIps(c *gin.Context)
	_addFrontEpNodeRoute(c *gin.Context)
	_addFrontEpIpsRoute(c *gin.Context)
	_getGatewayAddrsAndPorts(c *gin.Context)
}

// 非公開のResourceController構造体
type resourceController struct {
	rs ResourceService
}

// ResourceControllerのコンストラクタ。
// 引数にResourceServiceを受け取り、ResourceController構造体のポインタを返却する。
func NewResourceController(rs ResourceService) ResourceController {
	return &resourceController{rs}
}

// TODOの取得
func (tc *resourceController) GetTodos(c *gin.Context) {
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "(rc *resourceController) GetTodos"})
}

/*
// TODOの取得
func (tc *resourceController) _invokeService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	addrs := rs.getGatewayAddrs(clientset)
	ports := rs.getGatewayPort(ic, "default")
	fmt.Printf("URL: %+v  %+v\n", addrs, ports)
	fmt.Printf("URL: %+v\n", c.Query("path")) //http://123.456.7.8/api/list
	//url := "http://34.146.130.74:31401/detail-asg/detail/111"
	path := fmt.Sprintf("%s", c.Query("path"))
	c.IndentedJSON(http.StatusOK, invokeService(ns, svcname, path))
}
*/

//-------------------

// 外部パッケージに公開するインタフェース
type ResourceService interface {
	GetTodos()
	getGatewayAddrs(clientset *kubernetes.Clientset) []string
	getGatewayPort(ic *versioned.Clientset, ns string) []string
	discoverServices(clientset *kubernetes.Clientset, ns string) []string
}

// 非公開のResourceService構造体
type resourceService struct {
}

// ResourceServiceのコンストラクタ。ResourceService構造体のポインタを返却する。
func NewResourceService() ResourceService {
	return &resourceService{}
}

// TODO取得処理
func (rs *resourceService) GetTodos() {
	fmt.Println("(rs *resourceService) GetTodos()\n")
	return
}

// dumel
// https://www.dumels.com/eyJ0aXRsZSI6Imh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvb29vc2hpL3NnbWUiLCJhZ2dyZWdhdGlvbnMiOnRydWUsImZpZWxkcyI6dHJ1ZSwibWV0aG9kcyI6dHJ1ZSwiY29tcG9zaXRpb25zIjp0cnVlLCJpbXBsZW1lbnRhdGlvbnMiOnRydWUsImFsaWFzZXMiOnRydWUsImNvbm5lY3Rpb25MYWJlbHMiOnRydWUsIm5vdGVzIjoiIn0=

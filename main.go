package main

// https://github.com/istio/client-go/blob/master/cmd/example/client.go
// https://pizi.netlify.app/posts/kubernetes-client-go-example/#pod%E3%81%AE%E5%8F%96%E5%BE%97
// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run client.go

// Golang restfulapi
// https://go.dev/doc/tutorial/web-service-gin
import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"
	"os"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"

	_ "k8sclienttest/docs" // directory name

	networkingv1alpha3 "istio.io/api/networking/v1alpha3"
	"istio.io/client-go/pkg/apis/networking/v1alpha3"
	"istio.io/client-go/pkg/clientset/versioned"
	versionedclient "istio.io/client-go/pkg/clientset/versioned"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/dynamic"

	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	//"k8s.io/apimachinery/pkg/runtime"
	//sigv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

//	_ "use_swagger/docs" _ "k8sclienttest/docs"
// _ "github.com/swaggo/gin-swagger/example/basic/docs" // docs is generated by Swag CLI, you have to import it.

// @Summary registerGateway
// @Description registerGateway
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   ip     path    string     true        "gateway external ip address"
// @Success 200 "ok"
// @Router /registerGateway/{ns}/{ip} [get]
func _registerGateway(c *gin.Context) {
	ns := c.Param("ns")
	ip := c.Param("ip")
	strIp := registerGateway(clientset, ns, ip)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": strIp})
}
func registerGateway(clientset *kubernetes.Clientset, ns string, ip string) string {

	// https://stackoverflow.com/questions/70345467/how-to-create-config-map-and-secrets-using-golang-kubernetes-api
	// http://blog.johandry.com/post/build-k8s-client/
	// kubectl get configmap game-data -o yaml
	configMapData := make(map[string]string, 0)

	//gatewayEndpoint := `asg.one=34.146.130.74`
	gatewayEndpoint := ip
	/*
		uiProperties := `
				color.good=purple
				color.bad=yellow
				allow.textmode=false
			`
		configMapData["ui.properties"] = uiProperties
	*/
	//configMapData["gateway.endpoints"] = gatewayEndpoints
	configMapData["gateway.endpoint"] = gatewayEndpoint
	configMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "gateway-data",
			Namespace: ns,
		},
		Data: configMapData,
	}

	var cm *corev1.ConfigMap
	if _, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), "gateway-data", metav1.GetOptions{}); errors.IsNotFound(err) {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Update(context.TODO(), &configMap, metav1.UpdateOptions{})
	}
	//https://stackoverflow.com/questions/27545270/how-to-get-a-value-from-map
	log.Printf("Registered in configmap: gateway %+v\n", cm.Data["gateway.endpoint"])
	str := fmt.Sprintf("%+v", cm.Data["gateway.endpoint"])
	return str
}

// @Summary discoverGateway
// @Description discoverGateway
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Success 200 "ok"
// @Router /discoverGateway/{ns} [get]
func _discoverGateway(c *gin.Context) {
	ns := c.Param("ns")
	ips := discoverGateway(clientset, ns)
	ports := discoverGatewayPort(ic, ns)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "http://" + ips[0] + ":" + ports[0]})
}
func discoverGateway(clientset *kubernetes.Clientset, ns string) []string {
	var arr []string
	var cm *corev1.ConfigMap
	cm, _ = clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), "gateway-data", metav1.GetOptions{})
	log.Printf("Registered in configmap: gateway %+v\n", cm.Data["gateway.endpoint"])
	str := fmt.Sprintf("%+v", cm.Data["gateway.endpoint"])
	arr = append(arr, str)
	return arr
}

// https://pizi.netlify.app/posts/kubernetes-client-go-example/#node%E3%81%AE%E5%8F%96%E5%BE%97
//func discoverNodes(clientset *kubernetes.Clientset) []string {
func discoverNodes() {
	// https://godoc.org/k8s.io/client-go/kubernetes/typed/core/v1
	nodes, err := clientset.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get nodes:", err)
	}

	for i, node := range nodes.Items {
		fmt.Printf("[%d] %s\n", i, node.GetName())
	}
	nodeip := []corev1.NodeAddress{}
	for i := 0; i < len(nodes.Items); i++ {
		nodeip = nodes.Items[i].Status.Addresses
		fmt.Println(nodeip[0].Address)
	}
	fmt.Println(nodes.Items[0].Status.Addresses)

}

// @Summary discoverGatewayPort
// @Description discoverGatewayPort
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Success 200 "ok"
// @Router /discoverGatewayPort/{ns} [get]
func _discoverGatewayPort(c *gin.Context) {
	ns := c.Param("ns")
	discoverGatewayPort(ic, ns)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
func discoverGatewayPort(ic *versioned.Clientset, ns string) []string {
	var arr []string
	// Test VirtualServices
	vsList, err := ic.NetworkingV1alpha3().VirtualServices(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalf("Failed to get VirtualService in %s namespace: %s", ns, err)
	}

	for i := range vsList.Items {
		vs := vsList.Items[i]
		log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.GetHosts())
		//log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.Http[0].Match[0].Uri)
		for j := range vs.Spec.Http {
			log.Printf("[%d] Service Name: %+v, Uri: %+v\n", j, vs.Spec.Http[j].Route[0].Destination.Host, vs.Spec.Http[j].Match[0].Uri)
		}
	}

	// Test DestinationRules
	drList, err := ic.NetworkingV1alpha3().DestinationRules(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalf("Failed to get DestinationRule in %s namespace: %s", ns, err)
	}

	for i := range drList.Items {
		dr := drList.Items[i]
		log.Printf("Index: %d DestinationRule Host: %+v\n", i, dr.Spec.GetHost())
	}

	// Test Gateway
	gwList, err := ic.NetworkingV1alpha3().Gateways(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalf("Failed to get Gateway in %s namespace: %s", ns, err)
	}

	for i := range gwList.Items {
		gw := gwList.Items[i]
		vs := vsList.Items[i]
		for _, s := range gw.Spec.GetServers() {
			//log.Printf("Index: %d Gateway servers: %+v\n", i, s.GetPort().Number)
			log.Printf("http://%+v:%+v\n", vs.Spec.GetHosts()[0], s.GetPort().Number)
			//str := fmt.Sprintf("http://%+v:%+v", vs.Spec.GetHosts()[0], s.GetPort().Number)
			str := fmt.Sprintf("%+v", s.GetPort().Number)
			arr = append(arr, str)
		}
	}
	return arr
}

// @Summary addServiceApidocUrl
// @Description addServiceApidocUrl
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Param   apidocurl     path    string     true        "api document url"
// @Success 200 "ok"
// @Router /addServiceApidocUrl/{ns}/{svcname}/{apidocurl} [get]
func _addServiceApidocUrl(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	apidocurl := c.Param("apidocurl")
	addServiceApidocUrl(ic, ns, svcname, apidocurl)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}

func addServiceApidocUrl(ic *versioned.Clientset, ns string, svcname string, apidocurl string) map[string]string {
	// https://stackoverflow.com/questions/70345467/how-to-create-config-map-and-secrets-using-golang-kubernetes-api
	// http://blog.johandry.com/post/build-k8s-client/
	// kubectl get configmap game-data -o yaml
	configMapData := make(map[string]string, 0)

	apidocUrl := apidocurl
	configMapData[svcname+".apidocurl"] = apidocUrl
	configMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      svcname + "-apidocurl",
			Namespace: ns,
		},
		Data: configMapData,
	}

	var cm *corev1.ConfigMap
	if _, err := clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), svcname+"-apidocurl", metav1.GetOptions{}); errors.IsNotFound(err) {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
		cm, _ = clientset.CoreV1().ConfigMaps(ns).Update(context.TODO(), &configMap, metav1.UpdateOptions{})
	}
	//https://stackoverflow.com/questions/27545270/how-to-get-a-value-from-map
	log.Printf("Registered in configmap: %s-apidocurl: %+v\n", svcname, cm.Data[svcname+".apidocurl"])
	//str := fmt.Sprintf("%+v", cm.Data[svcname+".apidocurl"])
	return map[string]string{svcname: apidocurl}
}

// @Summary discoverServiceApidocUrl
// @Description discoverServiceApidocUrl
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /discoverServiceApidocUrl/{ns}/{svcname} [get]
func _discoverServiceApidocUrl(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	str := discoverServiceApidocUrl(clientset, ns, svcname)
	//c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
	c.IndentedJSON(http.StatusOK, gin.H{svcname + ".apidocurl": str})
}
func discoverServiceApidocUrl(clientset *kubernetes.Clientset, ns string, svcname string) string {
	var cm *corev1.ConfigMap
	cm, _ = clientset.CoreV1().ConfigMaps(ns).Get(context.TODO(), svcname+"-apidocurl", metav1.GetOptions{})
	log.Printf("found configmap: %s-apidocurl: %+v\n", svcname, cm.Data[svcname+".apidocurl"])
	str := fmt.Sprintf("%+v", cm.Data[svcname+".apidocurl"])
	return str
}

type JSONPatch struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}
type JSONPatchList []*JSONPatch

func AddJsonPatch(jps ...*JSONPatch) JSONPatchList {
	list := make([]*JSONPatch, len(jps))
	for index, jp := range jps {
		list[index] = jp
	}
	return list
}

/*
// @Summary registerService
// @Description registerService
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /registerService/{ns}/{svcname} [get]
func _registerService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	//  /registerService/{ns}/{vsname}/{uriName}/{uriPrefix}/{uriRewrite}/{host}/{port} [get]
	//vsname := c.Param("vsname")
	//uriName := c.Param("uriName")
	//uriPrefix := c.Param("uriPrefix")
	//uriRewrite := c.Param("uriRewrite")
	//host := c.Param("host")
	//port := c.Param("port")
	service, err := clientset.CoreV1().Services(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got service: %+v\n", service.GetName())
	log.Printf("GOt service port: %+v\n", service.Spec.Ports[0].Port)
	//i64Port, _ := strconv.ParseInt(port, 10, 16)
	port := service.Spec.Ports[0].Port
	//registerService(dc, ns, vsname, uriName, uriPrefix, uriRewrite, host, int32(i64Port))
	registerService(dc, ns, svcname, svcname, "/"+svcname, "/", svcname+"."+ns+".svc.cluster.local", port)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
*/

// @Summary registerService
// @Description registerService
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /registerService/{ns}/{svcname} [get]
func _registerService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	service, err := clientset.CoreV1().Services(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got service: %+v\n", service.GetName())
	log.Printf("Got service port: %+v\n", service.Spec.Ports[0].Port)
	port := service.Spec.Ports[0].Port
	registerService(dc, ns, "vs-customer-gateway", svcname, "/"+svcname+"-asg/", "/", svcname+"."+ns+".svc.cluster.local", port)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "/" + svcname + "-asg"})
}
func registerService(dc dynamic.Interface, ns string, vsname string, uriName string, uriPrefix string, uriRewrite string, host string, port int32) {
	//  Create a GVR which represents an Istio Virtual Service.
	gvr := schema.GroupVersionResource{
		Group:    "networking.istio.io",
		Version:  "v1alpha3",
		Resource: "virtualservices",
	}
	_, err := dc.Resource(gvr).Namespace("default").Get(context.TODO(), vsname, metav1.GetOptions{})
	//res, err := dc.Resource(gvr).Namespace("default").Get(context.TODO(), vsname, metav1.GetOptions{})
	//log.Print(res)
	if err != nil {
		log.Print(err)
	}

	list := AddJsonPatch(
		&JSONPatch{
			Op:   "add",
			Path: "/spec/http/-",
			Value: map[string]interface{}{
				"name": host,
				"match": []map[string]interface{}{
					{
						"uri": map[string]interface{}{
							"prefix": uriPrefix,
						},
					},
				},
				"rewrite": map[string]interface{}{
					"uri": uriRewrite,
				},
				"route": []map[string]interface{}{
					{
						"destination": map[string]interface{}{
							"host": host,
							"port": map[string]interface{}{
								"number": port,
							},
						},
					},
				},
			},
		})
	b, _ := json.Marshal(list)
	//  Apply the patch to the service.
	uvs, err := dc.Resource(gvr).Namespace("default").Patch(context.TODO(), vsname, types.JSONPatchType, b, metav1.PatchOptions{})

	httpSlice, _, _ := unstructured.NestedSlice(uvs.Object, "spec", "http")
	//fmt.Printf("Read http slice %+v\n", httpSlice[0]) //returns []interface{}, NOT map[string]interface{} map[match:[map[uri:map[prefix:/detail-asg/]]] name:detail.default.svc.cluster.local rewrite:map[uri:/] route:[map[destination:map[host:detail.default.svc.cluster.local port:map[number:3006]]]]]
	for i, v := range httpSlice { //
		fmt.Println(i, v)
	}

	// marshal unstructed into indented json
	// pass unstructured, NOT unstructed.Object
	jRead, _ := uvs.MarshalJSON()
	var buf bytes.Buffer
	err = json.Indent(&buf, []byte(jRead), "", "  ")
	if err != nil {
		panic(err)
	}
	//indentJson := buf.String()
	//fmt.Printf("indentJson %s/\n", indentJson)

	if err != nil {
		log.Print(err)
	}
}

// @Summary discoverServices
// @Description discoverServices
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Success 200 "ok"
// @Router /discoverServices{ns} [get]
func _discoverServices(c *gin.Context) {
	ns := c.Param("ns")
	discoverServices(clientset, ns)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
func discoverServices(clientset *kubernetes.Clientset, ns string) []string {
	services, err := clientset.CoreV1().Services(ns).List(context.TODO(), metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get services:", err)
	}
	var arr []string
	for _, svc := range services.Items {
		//fmt.Printf("[%d] %s\n", i, svc.GetName())
		arr = append(arr, svc.GetName())
	}
	return arr
}

// @Summary discoverService
// @Description discoverService
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /discoverService/{ns}/{svcname} [get]
func _discoverService(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")

	invokingPath := discoverService(clientset, ns, svcname)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": invokingPath})
}
func discoverService(clientset *kubernetes.Clientset, ns string, svcname string) string {

	service, err := clientset.CoreV1().Services(ns).Get(context.TODO(), svcname, metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got service: %+v\n", service.GetName())
	str := fmt.Sprintf("/%+v-asg", service.GetName())
	return str
}

// postLBConfig
// @Summary
// @Tags Istio Resouce Config
// @Accept  json
// @Produce  json
// @Param data body lb true "new LB policy to apply to service"
// @Success 200
// @Failure 400
// @Router /api/icg/lbConfig [post]

// @Summary circuitBreaker
// @Description circuitBreaker defines circuit breaker policy that applies to traffic intended for a service after routing has occurred.
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /circuitBreaker/{ns}/{svcname} [get]
func _circuitBreaker(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	circuitBreaker(ic, ns, svcname)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}
func circuitBreaker(ic *versioned.Clientset, ns string, svcname string) {

	// delete existing dr
	ic.NetworkingV1alpha3().DestinationRules(ns).Delete(context.TODO(), "dr-detail", v1.DeleteOptions{})

	var (
		destinationRule *v1alpha3.DestinationRule
	)

	destinationRule = &v1alpha3.DestinationRule{
		TypeMeta: v1.TypeMeta{},
		ObjectMeta: v1.ObjectMeta{
			Namespace: ns,
			Name:      "dr-" + svcname,
		},
		Spec: networkingv1alpha3.DestinationRule{
			Host: svcname,
			TrafficPolicy: &networkingv1alpha3.TrafficPolicy{
				LoadBalancer: &networkingv1alpha3.LoadBalancerSettings{
					LbPolicy: &networkingv1alpha3.LoadBalancerSettings_Simple{
						Simple: networkingv1alpha3.LoadBalancerSettings_SimpleLB(4), //networkingv1alpha3.LoadBalancerSettings_PASSTHROUGH, Lb      int32  `json:"lb" example:"4"` // round-robin
					},
					LocalityLbSetting: nil,
				},
				//
				ConnectionPool: &networkingv1alpha3.ConnectionPoolSettings{
					Tcp: &networkingv1alpha3.ConnectionPoolSettings_TCPSettings{
						// Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.
						MaxConnections: 200,
						// TCP connection timeout. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
						ConnectTimeout: nil,
					},
					Http: &networkingv1alpha3.ConnectionPoolSettings_HTTPSettings{
						// Maximum number of pending HTTP requests to a destination. Default 2^32-1.
						// 最大请求数
						Http1MaxPendingRequests: 200,
						// Maximum number of requests to a backend. Default 2^32-1.
						// 每个后端最大请求数
						Http2MaxRequests: 20,
						// Maximum number of requests per connection to a backend. Setting this
						// parameter to 1 disables keep alive. Default 0, meaning "unlimited",
						// up to 2^29.
						// 是否启用keepalive对后端进行长链接 0 表示启用
						MaxRequestsPerConnection: 0,
						// Maximum number of retries that can be outstanding to all hosts in a
						// cluster at a given time. Defaults to 2^32-1.
						// 在给定时间内最大的重试次数
						MaxRetries: 1,
						// The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests.
						// If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed.
						// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.
						// 不设置默认1小时没有请求，断开后端连接
						IdleTimeout: nil,
						// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
						//H2UpgradePolicy:          0,
					},
				},
				//
				// 类似nginx的 next upstream
				//OutlierDetection:     nil,
				//Tls:                  nil,
				//PortLevelSettings: nil,
			},
		},
	}
	dr, err := ic.NetworkingV1alpha3().DestinationRules(ns).Create(context.TODO(), destinationRule, v1.CreateOptions{})
	if err != nil {
		log.Print(err)
		return
	}
	log.Print(dr)
}

// http://localhost:8080/invokeServiceEndpoint?method=get&path=/api/hello&svcname=detail
// https://qiita.com/taizo/items/c397dbfed7215969b0a5
// HTTPリクエストのレスポンスを構造体定義なしでjsonに吐き出す方法
// https://shiimanblog.com/engineering/output-json/
func _invokeServiceEndpoint(c *gin.Context) {
	//invokeServiceEndpoint()
	fmt.Printf("%+v", c.Request.URL.Query()["svcname"])
	url := "http://34.146.130.74:31401/detail-asg/detail/111"
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("Authorization", "Bearer access-token")

	// request header
	dump, _ := httputil.DumpRequestOut(req, true)
	fmt.Printf("%s", dump)

	client := new(http.Client)
	resp, _ := client.Do(req)

	// response header
	dumpResp, _ := httputil.DumpResponse(resp, true)
	fmt.Printf("%s", dumpResp)

	// response body
	defer resp.Body.Close()
	body, _ := io.ReadAll(resp.Body)
	// JSONを構造体にエンコード
	var response interface{}
	json.Unmarshal(body, &response)
	c.IndentedJSON(http.StatusOK, response)
}

// @Summary discoverServiceEndpoints
// @Description discoverServiceEndpoints
// @Accept  json
// @Produce  json
// @Param   ns     path    string     true        "namespace"
// @Param   svcname     path    string     true        "service name"
// @Success 200 "ok"
// @Router /discoverServiceEndpoints/{ns}/{svcname} [get]
func _discoverServiceEndpoints(c *gin.Context) {
	ns := c.Param("ns")
	svcname := c.Param("svcname")
	c.IndentedJSON(http.StatusOK, discoverServiceEndpoints(clientset, ns, svcname))
}

//func discoverServiceEndpoints(clientset *kubernetes.Clientset, ns string, svcname string) *corev1.Endpoints.EndpointSubset {
func discoverServiceEndpoints(clientset *kubernetes.Clientset, ns string, svcname string) []corev1.EndpointSubset {
	//kubectl get ep detail
	/*
		service, err := clientset.CoreV1().Services("default").Get(context.TODO(), "detail", metav1.GetOptions{})
		if err != nil {
			log.Fatalln("failed to get service:", err)
		}
		log.Printf("Got service: %+v\n", service.GetName())
		str := fmt.Sprintf("/%+v-asg", service.GetName())
		log.Printf("Got str: %+v\n", str)
	*/
	endpoints, err := clientset.CoreV1().Endpoints("default").Get(context.TODO(), "detail", metav1.GetOptions{})
	if err != nil {
		log.Fatalln("failed to get service:", err)
	}
	log.Printf("Got endpoints. addresses: %+v, ports: %+v\n", endpoints.Subsets[0].Addresses, endpoints.Subsets[0].Ports[0])
	var addrs []string
	for _, addr := range endpoints.Subsets[0].Addresses {
		addrs = append(addrs, addr.IP)
	}

	fmt.Printf("addrs: %s, port: %d\n", addrs, endpoints.Subsets[0].Ports[0].Port)
	return endpoints.Subsets
}

// @description テスト用APIの詳細
// @version 1.0
// @accept application/x-json-stream
// @param none query string false "必須ではありません。"
// @Success 200
// @router /test/ [get]
func getTest(c *gin.Context) {
	id := c.Param("id")
	fmt.Printf(id)
	c.IndentedJSON(http.StatusOK, gin.H{"msg": "ok"})
}

var clientset *kubernetes.Clientset
var dc dynamic.Interface
var ic *versioned.Clientset

// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run main.go

// swagger doc how to write
// https://moneyforward.com/engineers_blog/2021/10/20/go-api-swagger/
// https://qiita.com/Syoitu/items/71ca216c271e2d3c14ca
// https://github.com/swaggo/gin-swagger/tree/master/example/basic/api

// @title SGME API
// @version 1.0

// @host 0.0.0.0:8080
// @BasePath /

func main() {

	kubeconfig := os.Getenv("KUBECONFIG")
	namespace := os.Getenv("NAMESPACE")

	if len(kubeconfig) == 0 || len(namespace) == 0 {
		log.Fatalf("Environment variables KUBECONFIG and NAMESPACE need to be set")
	}

	restConfig, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		log.Fatalf("Failed to create k8s rest client: %s", err)
	}

	clientset, err = kubernetes.NewForConfig(restConfig)
	if err != nil {
		log.Fatal(err)
	}

	dc, err = dynamic.NewForConfig(restConfig)
	if err != nil {
		panic(err.Error())
	}
	//addNewMsRouteToVs(dynamicClient, "default", "vs-customer-gateway", "uriName", "/uriprefixaa", "/uriRewrteaa", "svc-c.default.svc.cluster.local", 5000)

	/*
		// Get a resource (returns an unstructured object).
		resourceScheme := sigv1alpha3.SchemeBuilder.GroupVersion.WithResource("virtualservices")
		resp, err := dynamicClient.Resource(resourceScheme).Namespace("default").Get(context.TODO(), "vs-customer-gateway", metav1.GetOptions{})
		unstructured := resp.UnstructuredContent()
		var uvslist *v1alpha3.VirtualServiceList
		err = runtime.DefaultUnstructuredConverter.
			FromUnstructured(unstructured, &uvslist)
		if err != nil {
			panic(err)
		}
		fmt.Println(uvslist.Items)
	*/
	//addNewMsRouteToVs(dynamicClient, "default", "vs-customer-gateway", "uriName", "/uriprefixaa", "/uriRewrteaa", "svc-c.default.svc.cluster.local", 5000)

	//log.Printf(" %+v\n", registerGatewayIP(clientset, "default", "34.146.130.74"))
	/*
		//services, err := clientset.CoreV1().Services("").List(context.TODO(), metav1.ListOptions{}) // list services in all namespace
		services, err := clientset.CoreV1().Services("default").List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalln("failed to get services:", err)
		}
		for i, svc := range services.Items {
			fmt.Printf("[%d] %s\n", i, svc.GetName())
		}
	*/

	ic, err = versionedclient.NewForConfig(restConfig)
	if err != nil {
		log.Fatalf("Failed to create istio client: %s", err)
	}

	//log.Printf(" %+v\n", listGatewaysInNamespace(ic, "default"))
	/*
		// Test VirtualServices
		vsList, err := ic.NetworkingV1alpha3().VirtualServices(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get VirtualService in %s namespace: %s", namespace, err)
		}

		for i := range vsList.Items {
			vs := vsList.Items[i]
			log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.GetHosts())
			//log.Printf("Index: %d VirtualService Hosts: %+v\n", i, vs.Spec.Http[0].Match[0].Uri)
			for j := range vs.Spec.Http {
				log.Printf("[%d] Service Name: %+v, Uri: %+v\n", j, vs.Spec.Http[j].Route[0].Destination.Host, vs.Spec.Http[j].Match[0].Uri)
			}
		}

		// Test DestinationRules
		drList, err := ic.NetworkingV1alpha3().DestinationRules(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get DestinationRule in %s namespace: %s", namespace, err)
		}

		for i := range drList.Items {
			dr := drList.Items[i]
			log.Printf("Index: %d DestinationRule Host: %+v\n", i, dr.Spec.GetHost())
		}

		// Test Gateway
		gwList, err := ic.NetworkingV1alpha3().Gateways(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get Gateway in %s namespace: %s", namespace, err)
		}

		for i := range gwList.Items {
			gw := gwList.Items[i]
			vs := vsList.Items[i]
			for _, s := range gw.Spec.GetServers() {
				//log.Printf("Index: %d Gateway servers: %+v\n", i, s.GetPort().Number)
				log.Printf("http://%+v:%+v\n", vs.Spec.GetHosts()[0], s.GetPort().Number)
			}
		}

		// Test ServiceEntry
		seList, err := ic.NetworkingV1alpha3().ServiceEntries(namespace).List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatalf("Failed to get ServiceEntry in %s namespace: %s", namespace, err)
		}

		for i := range seList.Items {
			se := seList.Items[i]
			for _, h := range se.Spec.GetHosts() {
				log.Printf("Index: %d ServiceEntry hosts: %+v\n", i, h)
			}
		}
	*/

	// -------------------------------------------------------------------
	// Restful API impl.

	router := gin.Default()
	//https://qiita.com/ichi_zamurai/items/97e7e93bf398f98e719e
	//https://github.com/gin-contrib/cors
	router.Use(cors.New(cors.Config{
		// アクセス許可するオリジン
		AllowOrigins: []string{
			"*",
			//"http://localhost:3000", // for frontend SPA client
			//"http://localhost:8080", // for swagger
		},
		// アクセス許可するHTTPメソッド
		AllowMethods: []string{
			//"POST",
			//"GET",
			//"OPTIONS",
			"*",
		},
		// 許可するHTTPリクエストヘッダ
		AllowHeaders: []string{
			//"Access-Control-Allow-Origin",
			"*",
		},
		// cookieなどの情報を必要とするかどうか
		AllowCredentials: false,
	}))

	router.GET("/test/:id", getTest)
	router.GET("/registerGateway/:ns/:ip", _registerGateway)
	router.GET("/discoverGateway/:ns", _discoverGateway)
	router.GET("/discoverGatewayPort/:ns", _discoverGatewayPort)                     //http://localhost:8080/test/3
	router.GET("/addServiceApidocUrl/:ns/:svcname/:apidocurl", _addServiceApidocUrl) // http://localhost:8080/addServiceApidocUrl/default/svcname/apidocurl
	router.GET("/discoverServiceApidocUrl/:ns/:svcname", _discoverServiceApidocUrl)
	//router.GET("/registerService/:ns/:vsname/:uriName/:uriPrefix/:uriRewrite/:host/:port", _registerService)
	router.GET("/registerService/:ns/:svcname", _registerService)
	router.GET("/discoverService/:ns/:svcname", _discoverService)
	router.GET("/discoverServices/:ns", _discoverServices)
	router.GET("/circuitBreaker/:ns/:svcname", _circuitBreaker)
	router.GET("/invokeServiceEndpoint", _invokeServiceEndpoint)
	router.GET("/discoverServiceEndpoints/:ns/:svcname", _discoverServiceEndpoints)

	//url := ginSwagger.URL("http://localhost:8080/swagger/doc.json")
	//router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// export GO111MODULE=on
	// rm go.mod
	// go mod init
	// go mod tidy
	// swag init
	// export KUBECONFIG='/Users/satoshiaikawa/.kube/config' && export NAMESPACE='default' && go run main.go
	// http://localhost:8080/swagger/index.html
	router.Run("0.0.0.0:8080")

}

// https://vivinko.com/inoue/blog/2021/10/07/154349.html
// petstore example
// docker pull swaggerapi/swagger-editor
// docker run -d -p 8888:8080 swaggerapi/swagger-editor
// swagger2markdown
// docker pull swagger2markup/swagger2markup
// docker run --rm -v $(pwd):/opt swagger2markup/swagger2markup convert -i /opt/swagger.yaml -f /opt/swagger -c /opt/config.properties
// docker run --platform linux/x86_64 --rm -v $(pwd):/opt swagger2markup/swagger2markup convert -i /opt/swagger.yaml -f /opt/swagger -c /opt/config.properties
// docker exec -it sh
// ps

//circuit breaker
/*
	ConnectionPool: &networkingv1alpha3.ConnectionPoolSettings{
		Tcp: &networkingv1alpha3.ConnectionPoolSettings_TCPSettings{
			// Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.
			MaxConnections: 200,
			// TCP connection timeout. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
			ConnectTimeout: nil,
		},
		Http: &networkingv1alpha3.ConnectionPoolSettings_HTTPSettings{
			// Maximum number of pending HTTP requests to a destination. Default 2^32-1.
			// 最大请求数
			Http1MaxPendingRequests: 200,
			// Maximum number of requests to a backend. Default 2^32-1.
			// 每个后端最大请求数
			Http2MaxRequests: 20,
			// Maximum number of requests per connection to a backend. Setting this
			// parameter to 1 disables keep alive. Default 0, meaning "unlimited",
			// up to 2^29.
			// 是否启用keepalive对后端进行长链接 0 表示启用
			MaxRequestsPerConnection: 0,
			// Maximum number of retries that can be outstanding to all hosts in a
			// cluster at a given time. Defaults to 2^32-1.
			// 在给定时间内最大的重试次数
			MaxRetries: 1,
			// The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests.
			// If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed.
			// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.
			// 不设置默认1小时没有请求，断开后端连接
			IdleTimeout: nil,
			// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
			//H2UpgradePolicy:          0,
		},
	},
*/
